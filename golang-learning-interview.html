<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-CN,en,default"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css"><link rel="stylesheet" href="/css/main.css?v=7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1"><link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.1.1",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!1,fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="收集了一些Golang中常见但容易入”坑”的知识点。"><meta name="keywords" content="Golang"><meta property="og:type" content="article"><meta property="og:title" content="Golang学习(面试篇)"><meta property="og:url" content="http://yoursite.com/golang-learning-interview.html"><meta property="og:site_name" content="Be the change you want to see in the world !"><meta property="og:description" content="收集了一些Golang中常见但容易入”坑”的知识点。"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2019-10-31T07:56:46.961Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Golang学习(面试篇)"><meta name="twitter:description" content="收集了一些Golang中常见但容易入”坑”的知识点。"><link rel="canonical" href="http://yoursite.com/golang-learning-interview"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>Golang学习(面试篇) | Be the change you want to see in the world !</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Be the change you want to see in the world !</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li></ul></nav></div></header><a href="https://github.com/BeDreamCoder" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/golang-learning-interview.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content><meta itemprop="description" content><meta itemprop="image" content="/uploads/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Be the change you want to see in the world !"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Golang学习(面试篇)</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-31 15:46:04 / 修改时间：15:56:46" itemprop="dateCreated datePublished" datetime="2019-10-31T15:46:04+08:00">2019-10-31</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数： <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>收集了一些Golang中常见但容易入”坑”的知识点。<br><a id="more"></a></p><h1 id="考点：defer执行顺序"><a href="#考点：defer执行顺序" class="headerlink" title="考点：defer执行顺序"></a>考点：<code>defer</code>执行顺序</h1><p>问题：写出下面代码输出内容<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	defer_call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defer_call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;fmt.Println(<span class="string">"打印前"</span>)&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;fmt.Println(<span class="string">"打印中"</span>)&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;fmt.Println(<span class="string">"打印后"</span>)&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"触发异常"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">打印后</span><br><span class="line">打印中</span><br><span class="line">打印前</span><br><span class="line"><span class="built_in">panic</span>: 触发异常</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.defer_call()</span><br><span class="line">	/tmp/sandbox550202885/prog.<span class="keyword">go</span>:<span class="number">15</span> +<span class="number">0xe0</span></span><br><span class="line">main.main()</span><br><span class="line">	/tmp/sandbox550202885/prog.<span class="keyword">go</span>:<span class="number">8</span> +<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">Program exited: status <span class="number">2.</span></span><br></pre></td></tr></table></figure><p></p><p>解析：</p><blockquote><p>defer 是后进先出。panic 需要等defer 结束后才会向上传递。出现panic的时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。</p></blockquote><p>拓展：</p><blockquote><p>defer、panic、recover、return的使用场景</p><p>panic和recover的使用规则:</p><ol><li>调用panic后，调用方函数执行从当前调用点退出</li><li>通过panic可以设定返回值,当panic函数没有被调用或者没有返回值时，recover返回Nil</li><li>recover函数只有在defer代码块中才会有效果</li><li>defer只对当前协程有效（main可以看作是主协程）</li><li>当panic发生时依然会执行当前（主）协程中已声明的defer，但如果所有defer都未调用recover()进行异常恢复，则会在执行完所有defer后引发整个进程崩溃；</li><li>主动调用os.Exit(int)退出进程时，已声明的defer将不再被执行。</li></ol></blockquote><p>情景1<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 必须要先声明defer，否则不能捕获到panic异常</span></span><br><span class="line">		fmt.Println(<span class="string">"c"</span>)</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err) <span class="comment">// 这里的err其实就是panic传入的内容，55</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"d"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	f()</span><br><span class="line">	fmt.Println(<span class="string">"e"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"a"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="number">55</span>)</span><br><span class="line">	fmt.Println(<span class="string">"b"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./prog.<span class="keyword">go</span>:<span class="number">21</span>:<span class="number">2</span>: unreachable code</span><br><span class="line">Go vet exited.</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line"><span class="number">55</span></span><br><span class="line">d</span><br></pre></td></tr></table></figure><p></p><p>分析：</p><blockquote><p>如上规则1，调用panic后，调用方函数执行从当前调用点退出</p></blockquote><p>情景2<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	i++</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><p>分析：</p><blockquote><p>Go 语言中所有的函数调用其实都是值传递的，defer 虽然是一个关键字，但是也继承了这个特性</p></blockquote><p>假设我们有以下的代码，在运行这段代码时会打印出 <code>0</code>：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Test)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(t.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test := Test&#123;&#125;</span><br><span class="line">	<span class="keyword">defer</span> test.<span class="built_in">print</span>()</span><br><span class="line">	test.value += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这其实表明当<code>defer</code>调用时其实会对函数中引用的外部参数进行拷贝，所以 test.value += 1 操作并没有修改被 defer 捕获的 test 结构体，不过如果我们修改 print 函数签名的话，其实结果就输出<code>1</code>：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(t.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test := Test&#123;&#125;</span><br><span class="line">	<span class="keyword">defer</span> test.<span class="built_in">print</span>()</span><br><span class="line">	test.value += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里再调用 defer关键字时其实也是进行的值传递，只是发生复制的是指向 test 的指针，我们可以将 test 变量理解成 print函数的第一个参数，在上一段代码中这个参数的类型是结构体，所以会复制整个结构体，而在这段代码中，拷贝的其实是指针，所以当我们修改 test.value 时，defer捕获的指针其实就能够访问到修改后的变量了。</p><p>情景3<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"entering:"</span>, s)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"leaving:"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> un(trace(<span class="string">"a"</span>))</span><br><span class="line">	fmt.Println(<span class="string">"in a"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> un(trace(<span class="string">"b"</span>))</span><br><span class="line">	fmt.Println(<span class="string">"in b"</span>)</span><br><span class="line">	a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></figure><p></p><p>分析：</p><blockquote><p>defer声明时会先计算确定参数的值，defer推迟执行的仅是其函数体。因此会先执行trace()</p></blockquote><p>如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> P(time.Now())</span><br><span class="line">	time.Sleep(<span class="number">5e9</span>)</span><br><span class="line">	fmt.Println(<span class="string">"1"</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">P</span><span class="params">(t time.Time)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"2"</span>, t)</span><br><span class="line">	fmt.Println(<span class="string">"3"</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 1 2017-08-01 14:59:47.547597041 +0800 CST</span></span><br><span class="line"><span class="comment">// 2 2017-08-01 14:59:42.545136374 +0800 CST</span></span><br><span class="line"><span class="comment">// 3 2017-08-01 14:59:47.548833586 +0800 CST</span></span><br></pre></td></tr></table></figure><p></p><p>情景4<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">"defer runs"</span>)</span><br><span class="line">		fmt.Println(<span class="string">"block ends"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"main ends"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block ends</span><br><span class="line">main ends</span><br><span class="line"><span class="keyword">defer</span> runs</span><br></pre></td></tr></table></figure><p></p><p>分析：</p><blockquote><p><code>defer</code>并不是在退出当前代码块的作用域时执行的，<code>defer</code>只会在当前函数和方法返回之前被调用。</p></blockquote><p>情景5<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"in main"</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">"in goroutine"</span>)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">""</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">in goroutine</span><br><span class="line"><span class="built_in">panic</span>: </span><br><span class="line"></span><br><span class="line">goroutine <span class="number">6</span> [running]:</span><br><span class="line">main.main.func1()</span><br><span class="line">	/tmp/sandbox750445541/prog.<span class="keyword">go</span>:<span class="number">12</span> +<span class="number">0xa0</span></span><br><span class="line">created by main.main</span><br><span class="line">	/tmp/sandbox750445541/prog.<span class="keyword">go</span>:<span class="number">10</span> +<span class="number">0xa0</span></span><br></pre></td></tr></table></figure><p></p><p>分析：</p><blockquote><p>Go 语言在发生 panic 时只会执行当前协程中的 <code>defer</code>函数</p></blockquote><p>情景6<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"a return:"</span>, a()) <span class="comment">// 打印结果为 a return: 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">"a defer2:"</span>, i) <span class="comment">// 打印结果为 a defer2: 2</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">"a defer1:"</span>, i) <span class="comment">// 打印结果为 a defer1: 1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"b return:"</span>, b()) <span class="comment">// 打印结果为 b return: 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">"b defer2:"</span>, i) <span class="comment">// 打印结果为 b defer2: 2</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">"b defer1:"</span>, i) <span class="comment">// 打印结果为 b defer1: 1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> i <span class="comment">// 或者直接 return 效果相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><blockquote><p>defer、return、返回值三者的执行顺序应该是：return最先给返回值赋值；接着defer开始执行一些收尾工作；最后RET指令携带返回值退出函数。</p></blockquote><h1 id="考点：for-range"><a href="#考点：for-range" class="headerlink" title="考点：for range"></a>考点：for range</h1><p>问题：以下代码有什么问题，说明原因。<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pase_student</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line"></span><br><span class="line">	stus := []student&#123;</span><br><span class="line">		&#123;Name: <span class="string">"zhou"</span>, Age: <span class="number">24</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">"li"</span>, Age: <span class="number">23</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">"wang"</span>, Age: <span class="number">22</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">		m[stu.Name] = &amp;stu</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>解答：</p><blockquote><p>这样的写法初学者经常会遇到的，很危险！ 与Java的foreach一样，都是使用副本的方式。所以m[stu.Name]=&amp;stu实际上一致指向同一个指针， 最终该指针的值为遍历的最后一个struct的值拷贝。 就像想修改切片元素的属性：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">	stu.Age = stu.Age + <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>也是不可行的。 大家可以试试打印出来：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pase_student</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line">	stus := []student&#123;</span><br><span class="line">		&#123;Name: <span class="string">"zhou"</span>, Age: <span class="number">24</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">"li"</span>, Age: <span class="number">23</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">"wang"</span>, Age: <span class="number">22</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 错误写法</span></span><br><span class="line">	<span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">		m[stu.Name] = &amp;stu</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		<span class="built_in">println</span>(k, <span class="string">"=&gt;"</span>, v.Name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 正确</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(stus); i++ &#123;</span><br><span class="line">		m[stus[i].Name] = &amp;stus[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		<span class="built_in">println</span>(k, <span class="string">"=&gt;"</span>, v.Name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>分析：</p><blockquote><p>for range创建了每个元素的副本（值拷贝），而不是直接返回每个元素的引用。每个副本的地址相同，因此value指向相同的地址。所以在for循环中使用并发就需要特别注意。因为并发，不同的goroutine可能会读取到相同的值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        t.Logf(<span class="string">"go routine value %d"</span>, value)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">blog_test.<span class="keyword">go</span>:<span class="number">15</span>: <span class="keyword">go</span> routine value <span class="number">3</span></span><br><span class="line">blog_test.<span class="keyword">go</span>:<span class="number">15</span>: <span class="keyword">go</span> routine value <span class="number">3</span></span><br><span class="line">blog_test.<span class="keyword">go</span>:<span class="number">15</span>: <span class="keyword">go</span> routine value <span class="number">3</span></span><br></pre></td></tr></table></figure><p>如何解决上面的问题，需要使用到值传递，重新再匿名函数中声明一个参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		t.Logf(<span class="string">"go routine value %d"</span>, value)</span><br><span class="line">	&#125;(value)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>拓展：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Test)</span> <span class="title">Point</span><span class="params">()</span></span> &#123; <span class="comment">// this  为指针</span></span><br><span class="line">	fmt.Println(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ts := []Test&#123;&#123;<span class="string">"a"</span>&#125;, &#123;<span class="string">"b"</span>&#125;, &#123;<span class="string">"c"</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">		<span class="keyword">defer</span> t.Point() <span class="comment">//输出 c c c</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>分析：</p><blockquote><p>考察defer和方法接收者的规则，在执行t.Point()时，得到的是t的地址（引用），for结束时，t被赋值为”c“的地址，main函数返回时，都在执行”c“的接收方法Point，所以输出都是”c”.</p></blockquote><h1 id="考点：goroutine-执行的随机性和闭包"><a href="#考点：goroutine-执行的随机性和闭包" class="headerlink" title="考点：goroutine 执行的随机性和闭包"></a>考点：goroutine 执行的随机性和闭包</h1><p>下面的代码会输出什么，并说明原因。<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">20</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"A: "</span>, i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"B: "</span>, i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>解答：</p><blockquote><p>谁也不知道执行后打印的顺序是什么样的，所以只能说是随机数字。但是A:均为输出10，B:从0~9输出(顺序不定)。 第一个go func中i是外部for的一个变量，地址不变化。遍历完成后，最终i=10。 故go func执行时，i的值始终是10。<br>第二个go func中i是函数参数，与外部for中的i完全是两个变量。 尾部(i)将发生值拷贝，go func内部指向值拷贝地址。</p></blockquote><h1 id="考点：struct的组合继承"><a href="#考点：struct的组合继承" class="headerlink" title="考点：struct的组合继承"></a>考点：struct的组合继承</h1><p>下面代码会输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">ShowA</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"showA"</span>)</span><br><span class="line">	p.ShowB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">ShowB</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"showB"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">	People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span> <span class="title">ShowB</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"teachershowB"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := Teacher&#123;&#125;</span><br><span class="line">	t.ShowA()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">showA</span><br><span class="line">showB</span><br></pre></td></tr></table></figure><p></p><p>分析：</p><blockquote><p>这是Golang的组合模式，可以实现OOP的继承。 被组合的类型People所包含的方法虽然升级成了外部类型Teacher这个组合类型的方法（一定要是匿名字段），但它们的方法(ShowA())调用时接受者并没有发生变化。 此时People类型并不知道自己会被什么类型组合，当然也就无法调用方法时去使用未知的组合者Teacher类型的功能。</p></blockquote><h1 id="考点：select随机性"><a href="#考点：select随机性" class="headerlink" title="考点：select随机性"></a>考点：select随机性</h1><p>下面代码会触发异常吗？请详细说明<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	int_chan &lt;- <span class="number">1</span></span><br><span class="line">	string_chan &lt;- <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">		fmt.Println(value)</span><br><span class="line">	<span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">		<span class="built_in">panic</span>(value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>解答：</p><blockquote><p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。</p><p>select会随机选择一个可用通道做收发操作。 所以代码是有可能触发异常，也有可能不会。</p><p>以下描述了 select 语句的语法：</p><ul><li>每个 case 都必须是一个通信</li><li>所有 channel 表达式都会被求值</li><li>所有被发送的表达式都会被求值</li><li>如果任意某个通信可以进行，它就执行，其他被忽略。</li><li>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。<br>否则：<ul><li>如果有 default 子句，则执行该语句。</li><li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li></ul></li></ul></blockquote><h1 id="考点：make默认值和append"><a href="#考点：make默认值和append" class="headerlink" title="考点：make默认值和append"></a>考点：make默认值和append</h1><p>请写出以下输入内容<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>)</span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>解答：</p><blockquote><p>make初始化是有默认值的哦，此处默认值为0</p><p>[00000123]</p></blockquote><h1 id="考点：chan缓存池"><a href="#考点：chan缓存池" class="headerlink" title="考点：chan缓存池"></a>考点：chan缓存池</h1><p>下面的迭代会有什么问题？<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *threadSafeSet)</span> <span class="title">Iter</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		set.RLock()</span><br><span class="line">		<span class="keyword">for</span> elem := <span class="keyword">range</span> set.s &#123;</span><br><span class="line">			ch &lt;- elem</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">		set.RUnlock()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>解答：</p><blockquote><p>既然是迭代就会要求set.s全部可以遍历一次。但是chan是没有缓存的，那就代表这写入一次就会阻塞。迭代可能不能完成。</p></blockquote><p>我们把代码恢复为可以运行的方式，看看效果<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> threadSafeSet <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.RWMutex</span><br><span class="line">	s []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *threadSafeSet)</span> <span class="title">Iter</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="comment">// ch := make(chan interface&#123;&#125;)</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(set.s))</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		set.RLock()</span><br><span class="line">		<span class="keyword">for</span> elem, value := <span class="keyword">range</span> set.s &#123;</span><br><span class="line">			ch &lt;- value</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"Iter:"</span>, elem, value)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">		set.RUnlock()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	th := threadSafeSet&#123;</span><br><span class="line">		s: []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	v := &lt;-th.Iter()</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="考点：方法接收者是值还是指针问题"><a href="#考点：方法接收者是值还是指针问题" class="headerlink" title="考点：方法接收者是值还是指针问题"></a>考点：方法接收者是值还是指针问题</h1><p>以下代码能编译过去吗？为什么？<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">	Speak(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Stduent <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Stduent)</span> <span class="title">Speak</span><span class="params">(think <span class="keyword">string</span>)</span> <span class="params">(talk <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> think == <span class="string">"bitch"</span> &#123;</span><br><span class="line">		talk = <span class="string">"Youare a good boy"</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		talk = <span class="string">"hi"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> peo People = Stduent&#123;&#125;</span><br><span class="line">	think := <span class="string">"bitch"</span></span><br><span class="line">	fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./prog.go:21:6: cannot use Stduent literal (type Stduent) as type People in assignment:</span><br><span class="line">	Stduent does not implement People (Speak method has pointer receiver)</span><br></pre></td></tr></table></figure><p></p><p>解答：</p><blockquote><p>编译不通过！ 方法接收者是指针时，接口的值只能是指针。</p></blockquote><h1 id="考点：interface内部结构"><a href="#考点：interface内部结构" class="headerlink" title="考点：interface内部结构"></a>考点：interface内部结构</h1><p>以下代码打印出来什么内容，说出为什么。<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">live</span><span class="params">()</span> <span class="title">People</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> stu *Student</span><br><span class="line">	<span class="keyword">return</span> stu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> live() == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"AAA"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"BBB"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BBB</span><br></pre></td></tr></table></figure><p></p><p>解答：</p><blockquote><p>很经典的题！这个考点是很多人忽略的interface内部结构。 go中的接口分为两种：</p></blockquote><p>一种是空接口类似这样：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var in interface&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p>他的底层结构如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//空接口</span></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//类型信息</span></span><br><span class="line">    _type *_type</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)</span></span><br><span class="line">    data  unsafe.Pointer </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>另一种如题目：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type People interface &#123;</span><br><span class="line">    Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>他们的底层结构如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//带有方法的接口</span><br><span class="line">type iface struct &#123;  </span><br><span class="line">    //存储type信息还有结构实现方法的集合</span><br><span class="line">    tab  *itab </span><br><span class="line">    //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line">type itab struct &#123;</span><br><span class="line">    inter  *interfacetype //接口类型</span><br><span class="line">    _type  *_type         //结构类型</span><br><span class="line">    link   *itab</span><br><span class="line">    bad    int32</span><br><span class="line">    inhash int32</span><br><span class="line">    fun    [1]uintptr     //可变大小方法集合</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">type _type struct &#123;</span><br><span class="line">    size       uintptr //类型大小</span><br><span class="line">    ptrdata    uintptr //前缀持有所有指针的内存大小</span><br><span class="line">    hash       uint32  //数据hash值</span><br><span class="line">    tflag     tflag</span><br><span class="line">    align      uint8   //对齐</span><br><span class="line">    fieldalign uint8   //嵌入结构体时的对齐</span><br><span class="line">    kind       uint8   //kind 有些枚举值kind等于0是无效的</span><br><span class="line">    alg       *typeAlg //函数指针数组，类型实现的所有方法</span><br><span class="line">    gcdata    *byte   str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>可以看出iface比eface 中间多了一层itab结构。 itab 存储_type信息和[]fun方法集，从上面的结构我们就可得出，因为data指向了nil 并不代表interface 是nil， 所以返回值并不为空，这里的fun(方法集)定义了接口的接收规则，在编译的过程中需要验证是否实现接口</p></blockquote><h1 id="考点：type的使用"><a href="#考点：type的使用" class="headerlink" title="考点：type的使用"></a>考点：type的使用</h1><p>是否可以编译通过？如果通过，输出什么？<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := GetValue()</span><br><span class="line">	<span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"int"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"string"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"interface"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"unknown"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetValue</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prog.go:6:2: cannot type switch on non-interface value i (type int)</span><br></pre></td></tr></table></figure><p></p><p>解析：</p><blockquote><p>编译失败，因为type只能使用在interface</p></blockquote><h1 id="考点：函数返回值命名规则"><a href="#考点：函数返回值命名规则" class="headerlink" title="考点：函数返回值命名规则"></a>考点：函数返回值命名规则</h1><p>下面函数有什么问题？<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mui</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>解析:</p><blockquote><p>在函数有多个返回值时，只要有一个返回值有指定命名，其他的也必须有命名；如果返回值有有多个返回值必须加上括号；如果只有一个返回值并且有命名也需要加上括号。</p><p>此处函数第一个返回值有sum名称，第二个未命名，所以错误。</p></blockquote><h1 id="考点-defer、return、函数返回值的执行顺序"><a href="#考点-defer、return、函数返回值的执行顺序" class="headerlink" title="考点: defer、return、函数返回值的执行顺序"></a>考点: defer、return、函数返回值的执行顺序</h1><p>14.是否可以编译通过？如果通过，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(DeferFunc1(<span class="number">1</span>))</span><br><span class="line">	<span class="built_in">println</span>(DeferFunc2(<span class="number">1</span>))</span><br><span class="line">	<span class="built_in">println</span>(DeferFunc3(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc1</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	t = i</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t += <span class="number">3</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc2</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	t := i</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t += <span class="number">3</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc3</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t += i</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>解析：</p><blockquote><p>需要明确一点是defer需要在函数结束前执行。 函数返回值名字会在函数起始处被初始化为对应类型的零值并且作用域为整个函数</p><p>defer、return、返回值三者的执行顺序应该是：return最先给返回值赋值；接着defer开始执行一些收尾工作；最后RET指令携带返回值退出函数。</p><p>DeferFunc1有函数返回值t作用域为整个函数，在return之前defer会被执行，所以t会被修改，返回4; DeferFunc2函数中t的作用域为函数，返回1;DeferFunc3返回3</p></blockquote><h1 id="考点：make和new的区别"><a href="#考点：make和new的区别" class="headerlink" title="考点：make和new的区别"></a>考点：make和new的区别</h1><p>是否可以编译通过？如果通过，输出什么？<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list := <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line">	list = <span class="built_in">append</span>(list, <span class="number">1</span>)</span><br><span class="line">	fmt.Println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prog.go:7:15: first argument to append must be slice; have *[]int</span><br></pre></td></tr></table></figure><p></p><p>解析:</p><blockquote><p>golang中只有三种引用类型它们分别是切片slice、字典map、管道channel。其它的全部是值类型，引用类型可以简单的理解为指针类型，它们都是通过make完成初始化。</p><p>内置函数 new 计算类型大小，为其分配零值内存，返回指针。而 make 会被编译器翻译 成具体的创建函数，由其分配内存和初始化成员结构，返回对象而非指针。</p><p>修改为： list := make([]int,0)</p></blockquote><h1 id="考点：结构体比较"><a href="#考点：结构体比较" class="headerlink" title="考点：结构体比较"></a>考点：结构体比较</h1><p>是否可以编译通过？如果通过，输出什么？<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sn1 := <span class="keyword">struct</span> &#123;</span><br><span class="line">		age  <span class="keyword">int</span></span><br><span class="line">		name <span class="keyword">string</span></span><br><span class="line">	&#125;&#123;age: <span class="number">11</span>, name: <span class="string">"qq"</span>&#125;</span><br><span class="line">	sn2 := <span class="keyword">struct</span> &#123;</span><br><span class="line">		age  <span class="keyword">int</span></span><br><span class="line">		name <span class="keyword">string</span></span><br><span class="line">	&#125;&#123;age: <span class="number">11</span>, name: <span class="string">"qq"</span>&#125;</span><br><span class="line">	<span class="keyword">if</span> sn1 == sn2 &#123;</span><br><span class="line">		fmt.Println(<span class="string">"sn1== sn2"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sm1 := <span class="keyword">struct</span> &#123;</span><br><span class="line">		age <span class="keyword">int</span></span><br><span class="line">		m   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	&#125;&#123;age: <span class="number">11</span>, m: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>: <span class="string">"1"</span>&#125;&#125;</span><br><span class="line">	sm2 := <span class="keyword">struct</span> &#123;</span><br><span class="line">		age <span class="keyword">int</span></span><br><span class="line">		m   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	&#125;&#123;age: <span class="number">11</span>, m: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>: <span class="string">"1"</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">if</span> sm1 == sm2 &#123;</span><br><span class="line">		fmt.Println(<span class="string">"sm1== sm2"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prog.go:26:9: invalid operation: sm1 == sm2 (struct containing map[string]string cannot be compared)</span><br></pre></td></tr></table></figure><p></p><p>解析:</p><blockquote><p>结构体是相同的，但是结构体属性中有不可以比较的类型，如map,slice,function。 所以该结构体不可比较。</p><p>可以使用reflect.DeepEqual进行比较</p></blockquote><h1 id="考点：iota"><a href="#考点：iota" class="headerlink" title="考点：iota"></a>考点：iota</h1><p>是否可以编译通过？如果通过，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	x = <span class="literal">iota</span></span><br><span class="line">	y</span><br><span class="line">	z = <span class="string">"zz"</span></span><br><span class="line">	k</span><br><span class="line">	p = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(x, y, z, k, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 zz zz 4</span><br></pre></td></tr></table></figure><p></p><p>解析:</p><blockquote><p>const声明中,每新增一行常量声明将使iota计数一次;iota仅能在const声明中使用;</p></blockquote><h1 id="考点-常量的内存分配"><a href="#考点-常量的内存分配" class="headerlink" title="考点:常量的内存分配"></a>考点:常量的内存分配</h1><p>下面函数有什么问题？<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cl = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bl = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(&amp;bl, bl)</span><br><span class="line">	<span class="built_in">println</span>(&amp;cl, cl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot take the address of cl</span><br></pre></td></tr></table></figure><p></p><p>解析:</p><blockquote><p>常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用</p></blockquote><h1 id="考点：goto"><a href="#考点：goto" class="headerlink" title="考点：goto"></a>考点：goto</h1><p>编译执行下面代码会出现什么?<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	loop:</span><br><span class="line">		<span class="built_in">println</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> loop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prog.go:8:7: goto loop jumps into block starting at ./prog.go:4:26</span><br></pre></td></tr></table></figure><p></p><p>解析:</p><blockquote><p>goto不能跳转到其他函数或者内层代码</p></blockquote><h1 id="考点：Go-1-9-新特性-Type-Alias"><a href="#考点：Go-1-9-新特性-Type-Alias" class="headerlink" title="考点：Go 1.9 新特性 Type Alias"></a>考点：Go 1.9 新特性 Type Alias</h1><p>25.编译执行下面代码会出现什么?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyUser1 User</span><br><span class="line"><span class="keyword">type</span> MyUser2 = User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i MyUser1)</span> <span class="title">m1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"MyUser1.m1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i User)</span> <span class="title">m2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"User.m2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i1 MyUser1</span><br><span class="line">	<span class="keyword">var</span> i2 MyUser2</span><br><span class="line">	i1.m1()</span><br><span class="line">	i2.m2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyUser1.m1</span><br><span class="line">User.m2</span><br></pre></td></tr></table></figure><p></p><p>解析:</p><blockquote><p>type MyInt1 int<br>type MyInt2 = int<br>第一行代码是基于基本类型int创建了新类型MyInt1(type defintion)，第二行是创建的一个int的类型别名MyInt2(type alias)，注意类型别名的定义是 <code>=</code>。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt1 <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> MyInt2 = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i MyInt1)</span> <span class="title">m1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"MyInt1.m1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i MyInt2)</span> <span class="title">m2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"MyInt2.m2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i1 MyInt1</span><br><span class="line">	<span class="keyword">var</span> i2 MyInt2</span><br><span class="line">	i1.m1()</span><br><span class="line">	i2.m2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./prog.go:12:6: cannot define new methods on non-local type int</span><br><span class="line">./prog.go:20:4: i2.m2 undefined (type int has no field or method m2)</span><br></pre></td></tr></table></figure><p></p><p>解析：</p><blockquote><p>因为int是一个非本地类型，所以我们不能为其增加方法。</p></blockquote><h1 id="考点：panic仅有最后一个可以被revover捕获"><a href="#考点：panic仅有最后一个可以被revover捕获" class="headerlink" title="考点：panic仅有最后一个可以被revover捕获"></a>考点：panic仅有最后一个可以被revover捕获</h1><p>编译执行下面代码会出现什么?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"fatal"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"defer panic"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"++++"</span>)</span><br><span class="line">			f := err.(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span>)</span></span><br><span class="line"><span class="function">			<span class="title">fmt</span>.<span class="title">Println</span><span class="params">(err, f()</span>, <span class="title">reflect</span>.<span class="title">TypeOf</span><span class="params">(err)</span>.<span class="title">Kind</span><span class="params">()</span>.<span class="title">String</span><span class="params">()</span>)</span></span><br><span class="line"><span class="function">		&#125; <span class="title">else</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"fatal"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"defer panic"</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main1:</span><br><span class="line">defer panic</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">++++</span><br><span class="line">0xe03e0 defer panic func</span><br></pre></td></tr></table></figure><p></p><p>解析:</p><blockquote><p>触发panic(“panic”)后顺序执行defer，但是defer中还有一个panic，所以覆盖了之前的panic(“panic”)</p></blockquote></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">本文结束 <i class="fa fa-paw"></i> 感谢您的阅读</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Golang/" rel="tag"><i class="fa fa-tag"></i> Golang</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/several-details-of-pbft.html" rel="next" title="PBFT的几个细节"><i class="fa fa-chevron-left"></i> PBFT的几个细节</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article></div></div><div class="comments" id="gitalk-container"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/uploads/avatar.jpeg" alt><p class="site-author-name" itemprop="name"></p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/BeDreamCoder" title="GitHub &rarr; https://github.com/BeDreamCoder" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a> </span><span class="links-of-author-item"><a href="mailto:tailinzhang1993@gmail.com" title="E-Mail &rarr; mailto:tailinzhang1993@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a> </span><span class="links-of-author-item"><a href="https://weibo.com/u/2484219913" title="Weibo &rarr; https://weibo.com/u/2484219913" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a></span></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：defer执行顺序"><span class="nav-number">1.</span> <span class="nav-text">考点：defer执行顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：for-range"><span class="nav-number">2.</span> <span class="nav-text">考点：for range</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：goroutine-执行的随机性和闭包"><span class="nav-number">3.</span> <span class="nav-text">考点：goroutine 执行的随机性和闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：struct的组合继承"><span class="nav-number">4.</span> <span class="nav-text">考点：struct的组合继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：select随机性"><span class="nav-number">5.</span> <span class="nav-text">考点：select随机性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：make默认值和append"><span class="nav-number">6.</span> <span class="nav-text">考点：make默认值和append</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：chan缓存池"><span class="nav-number">7.</span> <span class="nav-text">考点：chan缓存池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：方法接收者是值还是指针问题"><span class="nav-number">8.</span> <span class="nav-text">考点：方法接收者是值还是指针问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：interface内部结构"><span class="nav-number">9.</span> <span class="nav-text">考点：interface内部结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：type的使用"><span class="nav-number">10.</span> <span class="nav-text">考点：type的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：函数返回值命名规则"><span class="nav-number">11.</span> <span class="nav-text">考点：函数返回值命名规则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点-defer、return、函数返回值的执行顺序"><span class="nav-number">12.</span> <span class="nav-text">考点: defer、return、函数返回值的执行顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：make和new的区别"><span class="nav-number">13.</span> <span class="nav-text">考点：make和new的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：结构体比较"><span class="nav-number">14.</span> <span class="nav-text">考点：结构体比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：iota"><span class="nav-number">15.</span> <span class="nav-text">考点：iota</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点-常量的内存分配"><span class="nav-number">16.</span> <span class="nav-text">考点:常量的内存分配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：goto"><span class="nav-number">17.</span> <span class="nav-text">考点：goto</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：Go-1-9-新特性-Type-Alias"><span class="nav-number">18.</span> <span class="nav-text">考点：Go 1.9 新特性 Type Alias</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考点：panic仅有最后一个可以被revover捕获"><span class="nav-number">19.</span> <span class="nav-text">考点：panic仅有最后一个可以被revover捕获</span></a></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder"></span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.1.1"></script><script src="/js/motion.js?v=7.1.1"></script><script src="/js/affix.js?v=7.1.1"></script><script src="/js/schemes/pisces.js?v=7.1.1"></script><script src="/js/scrollspy.js?v=7.1.1"></script><script src="/js/post-details.js?v=7.1.1"></script><script src="/js/next-boot.js?v=7.1.1"></script><script src="/js/js.cookie.js?v=7.1.1"></script><script src="/js/scroll-cookie.js?v=7.1.1"></script><script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script><script>var gitalk=new Gitalk({clientID:"57512c2434a3178c8e71",clientSecret:"e4b5bee542e8bde2fb7fa0e94db73485ea3aff0c",repo:"bedreamcoder.github.io",owner:"BeDreamCoder",admin:["BeDreamCoder"],id:md5(location.pathname),language:"zh-CN",distractionFreeMode:"true"});gitalk.render("gitalk-container")</script></body></html>